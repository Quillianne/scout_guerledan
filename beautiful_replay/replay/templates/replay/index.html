<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beautiful Replay</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    :root { color-scheme: light; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    #map { height: calc(100vh - 70px); }
    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    label { font-size: 14px; }
    select, input, button { font-size: 14px; padding: 4px 6px; }
    .status { margin-left: auto; font-size: 13px; color: #555; }
    .hidden { display: none; }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .panel {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      width: min(900px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .panel h2 { margin: 0 0 12px; font-size: 18px; }
    .panel .controls { margin-bottom: 12px; }
    .panel .actions { display: flex; gap: 12px; align-items: center; justify-content: flex-end; }
  </style>
</head>
<body>
  <div id="configOverlay" class="overlay">
    <div class="panel">
      <h2>Configuration du replay</h2>
      <div class="controls">
        <label>Log
          <select id="logSelect"></select>
        </label>
        <label>Downsample
          <input id="downsample" type="number" min="1" value="5" />
        </label>
        <label>Init σ
          <input id="initUncertainty" type="number" min="0" step="0.1" value="0" />
        </label>
        <label>GPS σ
          <input id="gpsUncertainty" type="number" min="0" step="0.1" value="0" />
        </label>
        <label>Dist σ
          <input id="distUncertainty" type="number" min="0" step="0.1" value="0.1" />
        </label>
        <label>Move σ
          <input id="moveUncertainty" type="number" min="0" step="0.1" value="0.5" />
        </label>
        <label>Precision
          <input id="precision" type="number" min="0.1" step="0.1" value="1" />
        </label>
        <label>Margin
          <input id="margin" type="number" min="0" step="1" value="10" />
        </label>
        <label>Récursif
          <input id="recursive" type="checkbox" />
        </label>
      </div>
      <div class="actions">
        <button id="loadBtn">Visualiser</button>
      </div>
    </div>
  </div>

  <header>
    <div class="controls">
      <button id="changeLogBtn">Changer de log</button>
      <button id="playBtn">▶︎</button>
      <button id="pauseBtn">⏸</button>
      <label>Vitesse
        <input id="speed" type="range" min="0.25" max="10" step="0.25" value="1" />
        <span id="speedValue">1x</span>
      </label>
      <label>Temps
        <input id="timeSlider" type="range" min="0" max="0" step="1" value="0" />
      </label>
    </div>
    <div class="status" id="status">Idle</div>
  </header>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    const configOverlay = document.getElementById("configOverlay");
    const logSelect = document.getElementById("logSelect");
    const downsampleInput = document.getElementById("downsample");
    const initUncInput = document.getElementById("initUncertainty");
    const gpsUncInput = document.getElementById("gpsUncertainty");
    const distUncInput = document.getElementById("distUncertainty");
    const moveUncInput = document.getElementById("moveUncertainty");
    const precisionInput = document.getElementById("precision");
    const marginInput = document.getElementById("margin");
    const recursiveToggle = document.getElementById("recursive");
    const loadBtn = document.getElementById("loadBtn");
    const changeLogBtn = document.getElementById("changeLogBtn");
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const speedInput = document.getElementById("speed");
    const speedValue = document.getElementById("speedValue");
    const timeSlider = document.getElementById("timeSlider");
    const statusEl = document.getElementById("status");

    const map = L.map("map").setView([48.2, -3.0], 15);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 20,
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    const colors = ["#e53935", "#1e88e5", "#43a047"];
    const boatMarkers = colors.map((color) =>
      L.circleMarker([0, 0], { radius: 6, color, fillColor: color, fillOpacity: 1 }).addTo(map)
    );
    const boatTrails = colors.map((color) =>
      L.polyline([], { color, weight: 2, opacity: 0.6 }).addTo(map)
    );
    const boxLayers = colors.map((color) =>
      L.polygon([], { color, weight: 1, fillColor: color, fillOpacity: 0.15 }).addTo(map)
    );
    const pavingLayers = [
      L.layerGroup().addTo(map),
      L.layerGroup().addTo(map),
    ];

    let replayData = null;
    let playing = false;
    let currentIndex = 0;
    let lastFrameTime = null;
    let playbackTime = 0;

    async function loadLogs() {
      const res = await fetch("/api/logs/");
      const data = await res.json();
      logSelect.innerHTML = "";
      data.logs.forEach((name) => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        logSelect.appendChild(opt);
      });
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function showConfig() {
      configOverlay.classList.remove("hidden");
      configOverlay.style.display = "flex";
    }

    function hideConfig() {
      configOverlay.classList.add("hidden");
      configOverlay.style.display = "none";
    }

    function updateSpeedLabel() {
      speedValue.textContent = `${speedInput.value}x`;
    }

    function updateMap(index) {
      if (!replayData) return;
      const boats = replayData.boats;
      boats.forEach((boat, i) => {
        const gps = boat[index]?.gps;
        if (gps) {
          boatMarkers[i].setLatLng([gps[0], gps[1]]);
          const trail = boatTrails[i];
          const latlngs = trail.getLatLngs();
          latlngs.push([gps[0], gps[1]]);
          trail.setLatLngs(latlngs);
        }
      });

      // Prediction boxes: show last available box <= current index
      const pred = replayData.prediction;
      if (pred && pred.indices.length > 0) {
        if (index < pred.indices[0]) {
          boxLayers.forEach((layer) => layer.setLatLngs([]));
          pavingLayers.forEach((layer) => layer.clearLayers());
          timeSlider.value = index;
          return;
        }
        let boxIdx = 0;
        while (boxIdx + 1 < pred.indices.length && pred.indices[boxIdx + 1] <= index) {
          boxIdx++;
        }
        const boxes = pred.boxes[boxIdx];
        if (boxes) {
          boxes.forEach((poly, i) => {
            boxLayers[i].setLatLngs(poly.map(([lat, lon]) => [lat, lon]));
          });
        }

        const pavings = pred.pavings?.[boxIdx];
        pavingLayers.forEach((layer) => layer.clearLayers());
        if (pavings) {
          const scoutColors = [colors[1], colors[2]];
          pavings.forEach((scoutPaving, scoutIdx) => {
            const color = scoutColors[scoutIdx] || "#999";
            scoutPaving.forEach((poly) => {
              L.polygon(poly.map(([lat, lon]) => [lat, lon]), {
                color,
                weight: 1,
                fillColor: color,
                fillOpacity: 0.08,
              }).addTo(pavingLayers[scoutIdx]);
            });
          });
        }
      }

      timeSlider.value = index;
    }

    function animate(timestamp) {
      if (!playing || !replayData) return;
      if (lastFrameTime === null) lastFrameTime = timestamp;
      const dt = (timestamp - lastFrameTime) / 1000;
      const speed = parseFloat(speedInput.value);
      playbackTime += dt * speed;
      const times = replayData.times;
      while (currentIndex + 1 < times.length && times[currentIndex + 1] <= playbackTime) {
        currentIndex++;
      }
      updateMap(currentIndex);
      lastFrameTime = timestamp;
      if (currentIndex >= replayData.times.length - 1) {
        playing = false;
        setStatus("Terminé");
        return;
      }
      requestAnimationFrame(animate);
    }

    loadBtn.addEventListener("click", async () => {
      const log = logSelect.value;
      const downsample = downsampleInput.value || 1;
      const initUnc = initUncInput.value || 0;
      const gpsUnc = gpsUncInput.value || 0;
      const distUnc = distUncInput.value || 0.1;
      const moveUnc = moveUncInput.value || 0.5;
      const precision = precisionInput.value || 1.0;
      const margin = marginInput.value || 10.0;
      const recursive = recursiveToggle.checked ? 1 : 0;
      if (!log) return;
      setStatus("Chargement...");
      const res = await fetch(`/api/replay/?log=${encodeURIComponent(log)}&downsample=${downsample}`
        + `&init_uncertainty=${encodeURIComponent(initUnc)}`
        + `&gps_uncertainty=${encodeURIComponent(gpsUnc)}`
        + `&dist_uncertainty=${encodeURIComponent(distUnc)}`
        + `&move_uncertainty=${encodeURIComponent(moveUnc)}`
        + `&precision=${encodeURIComponent(precision)}`
        + `&margin=${encodeURIComponent(margin)}`
        + `&recursive=${encodeURIComponent(recursive)}`);
      if (!res.ok) {
        setStatus("Erreur de chargement");
        return;
      }
      replayData = await res.json();
      currentIndex = 0;
      lastFrameTime = null;
      playbackTime = 0;
      timeSlider.max = Math.max(0, replayData.times.length - 1);
      boatTrails.forEach((trail) => trail.setLatLngs([]));
      setStatus(`Chargé ${log}`);
      if (replayData.boats[0][0]?.gps) {
        const [lat, lon] = replayData.boats[0][0].gps;
        map.setView([lat, lon], 16);
      }
      updateMap(0);
      hideConfig();
    });

    changeLogBtn.addEventListener("click", () => {
      playing = false;
      setStatus("Idle");
      showConfig();
    });

    playBtn.addEventListener("click", () => {
      if (!replayData) return;
      playing = true;
      setStatus("Lecture");
      lastFrameTime = null;
      requestAnimationFrame(animate);
    });

    pauseBtn.addEventListener("click", () => {
      playing = false;
      setStatus("Pause");
    });

    timeSlider.addEventListener("input", (e) => {
      currentIndex = parseInt(e.target.value, 10) || 0;
      if (replayData && replayData.times) {
        playbackTime = replayData.times[currentIndex] || 0;
      }
      updateMap(currentIndex);
    });

    speedInput.addEventListener("input", updateSpeedLabel);

    updateSpeedLabel();
    loadLogs();
  </script>
</body>
</html>
