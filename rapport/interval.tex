\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amssymb}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{arrows.meta, positioning, calc, math, calc, shapes.geometric, quotes, angles}
\usepackage{caption}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage[noEnd=false, indLines=true]{algpseudocodex} % Lignes verticales et style moderne
\usepackage[most]{tcolorbox} % Pour les jolis cadres

% --- Définition des couleurs ---
\definecolor{algobg}{RGB}{245,245,245}      % Gris très clair pour le fond
\definecolor{algocomment}{RGB}{80,130,80}   % Vert pour les commentaires
\definecolor{algokeyword}{RGB}{0,50,120}    % Bleu profond pour les mots-clés
\definecolor{algoline}{RGB}{180,180,180}    % Gris pour les lignes verticales

% --- Configuration du style algorithmique ---
\algrenewcommand\algorithmiccomment[1]{\hfill \textcolor{algocomment}{$\triangleright$ \textit{#1}}}
\algrenewcommand\algorithmicrequire{\textbf{\textcolor{algokeyword}{Entrée:}}}
\algrenewcommand\algorithmicensure{\textbf{\textcolor{algokeyword}{Sortie:}}}
\algrenewcommand\textproc{} % Enlève les majuscules automatiques sur les noms de fonctions

% --- Création d'une boite jolie pour l'algo ---
\newtcolorbox{algo-box}[2][]{%
    enhanced,
    colback=white,
    colframe=algokeyword,
    boxrule=0.5pt,
    arc=3pt,
    title={\textbf{#2}}, % Titre en gras
    coltitle=white,
    attach boxed title to top left={yshift=-2mm, xshift=2mm},
    boxed title style={colback=algokeyword, sharp corners=south},
    #1
}


\begin{document}
\input{schema}
\section*{Contexte et objectif}

Ce travail vise à localiser trois bateaux coopérant au sein d'une même flotte : un bateau-mère \texttt{MS0}, dont la position absolue (GPS) peut être connue, et deux éclaireurs \texttt{S1} et \texttt{S2} dépourvus de GPS.

Les éclaireurs peuvent ponctuellement mesurer, par acoustique, les distances inter-bateaux :
$$d_{01},\;d_{12},\;d_{20},$$
chaque mesure étant entachée d'une incertitude modélisée par des intervalles. Par ailleurs, chaque unité a connaissance, à tout instant, de l'enveloppe de la position de ses voisins sous la forme de boîtes englobantes (\textit{bounding boxes}).

Ils disposent en outre de mesures instantanées de cap et de vitesse, elles aussi incertaines. En intégrant ces mesures entre deux instants, on obtient une estimation du déplacement total — avec son incertitude — procédé que l'on appelle le "dead-reckoning".

\begin{figure}[H]
\centering
\scalebox{0.70}{\SchemaModelisation}
\caption{Modélisation du problème}
\label{fig:schema_modelisation}
\end{figure}

Dans notre modèle, nous ne considérons pas les instants intermédiaires entre deux mesures acoustiques : au moment de la prochaine mesure, on suppose disponible le déplacement total $d$ depuis la dernière communication, où $d$ est un vecteur d'intervalles représentant l'incertitude issue du dead-reckoning. Le cycle d'estimation est alors :
\begin{itemize}
    \item \textbf{prédiction :} propager l'ensemble des positions possibles à l'aide de $d$ (dead-reckoning) ;
    \item \textbf{correction :} réduire cet ensemble lorsque des mesures acoustiques et/ou GPS sont disponibles, en exploitant les distances mesurées ainsi que les boîtes englobantes des voisins, via l'application de contracteurs adaptés.
\end{itemize}

\newpage

\section*{Prédiction par contracteurs équivalents}

Un contracteur réduit un ensemble de positions possibles en appliquant une contrainte (par exemple une mesure de distance ou une boîte GPS). On peut maintenir, tout au long du processus, un contracteur équivalent représentant les positions compatibles avec les contraintes accumulées. En translatant et en intersectant ce contracteur au fil du temps, puis en le pavant (par exemple via SIVIA) lorsqu'on souhaite obtenir explicitement l'ensemble des positions, on récupère l'enveloppe des solutions compatibles — d'où l'appellation de "contracteur équivalent".

Considérons le contracteur équivalent $C_{S1}(t-1)\subset\mathbb{R}^2$ du bateau \texttt{S1} à l'instant $t-1$. Le déplacement entre $t-1$ et $t$ est modélisé par
$$d = \begin{pmatrix}dx\\dy\end{pmatrix},$$
et la fonction arrière (utilisée dans le code comme \texttt{f\_back}) est
$$f_{\mathrm{back}}:\mathbb{R}^2\to\mathbb{R}^2,\qquad f_{\mathrm{back}}(x)=x-d.$$

Dans notre modèle, $dx$ et $dy$ sont des intervalles (par exemple $dx=[\underline{dx},\overline{dx}]$) : $d=(dx,dy)$ est le vecteur d'intervalles représentant le déplacement relatif. Pour un point réel $x\in\mathbb{R}^2$ et un vecteur d'intervalles $d$, l'expression $x-d$ s'interprète composante par composante dans l'arithmétique d'intervalles ; par exemple
$$x - dx = [x-\overline{dx},\;x-\underline{dx}].$$

Ainsi $x-d$ combine translation (par la valeur moyenne du déplacement) et inflation (par l'étendue des intervalles). La préimage s'écrit
$$f_{\mathrm{back}}^{-1}(C)=\{x\in\mathbb{R}^2\;|\;x-d\in C\},$$
et ainsi nous avons la prédiction de l'ensemble des positions à l'instant $t$ à partir de l'ensemble à l'instant $t-1$ :
$$C_{S1}(t)= f_{\mathrm{back}}^{-1}\bigl(C_{S1}(t-1)\bigr),$$

\begin{figure}[H]
\centering
\scalebox{0.60}{\SchemaPredictionSimple}
\caption{Prédiction : translation et inflation de l'ensemble des positions.}
\end{figure}

En termes de contracteurs, la prédiction s'effectue par
$$C_{S1}(t)=\mathrm{CtcInverse}\bigl(f_{\mathrm{back}},\;C_{S1}(t-1)\bigr),$$
le contracteur inverse retournant l'ensemble des états à l'instant $t$ dont l'image par $f_{\mathrm{back}}$ appartient à $C_{S1}(t-1)$.
On pourra appliquer la même logique à $C_{MS0}$ et $C_{S2}$


Ce calcul de prédiction par contracteur inverse est exact, mais peut être coûteux à maintenir récursivement et on observe dans la pratique qu'avoir une connaisance approximative de l'ensemble des positions à chaque instant est souvent suffisant pour la correction et c'est pourquoi on peut aussi opter pour une approche non récursive : au lieu de chaîner les contracteurs inverses, on peut simplement pavéer $C(t-1)$ et utiliser le pavage comme antécédent pour la prédiction à l'instant $t$.

\begin{figure}[H]
\centering
\scalebox{0.60}{\SchemaPredictionNonRecursive}
\caption{Approche non récursive : pavage de $C_{S1}(t-1)$ et translation vers $C_{S1}(t)$.}
\end{figure}

\newpage

\section*{Contracteurs de distance}

Les données d'entrée pour la phase de correction sont les mesures de distances inter-bateaux ($d_{01}, d_{12}, d_{20}$), modélisées par des intervalles pour inclure l'incertitude de mesure. De plus, chaque véhicule a connaissance de l'enveloppe de la position de ses voisins, transmise sous la forme de boîtes englobantes (\texttt{neighbor\_box} de type \texttt{IntervalVector}).

\paragraph{Justification du modèle}
L'utilisation de la boîte englobante pour représenter la position du voisin est un choix pragmatique lié aux contraintes du milieu sous-marin. Transmettre un \texttt{IntervalVector} est très économe en bande passante, contrairement à l'envoi d'un pavage complet (l'ensemble précis des sous-pavés validés) qui, bien qu'offrant une géométrie plus fine et potentiellement une meilleure contraction, induirait une complexité de communication et de calcul prohibitive.

\paragraph{Formulation de la contrainte}
Soit $x=(x_0, x_1)$ la position du bateau considéré et $b=(b_x, b_y)$ une position appartenant à la boîte du voisin $B_{\mathrm{neigh}}$. La fonction de distance euclidienne est définie par :
$$f_{\mathrm{dist}}(x)=\sqrt{(x_0-b_x)^2+(x_1-b_y)^2}.$$
Une mesure de distance reçue sous la forme d'un intervalle $[d_{\min}, d_{\max}]$ induit la contrainte d'appartenance suivante :
$$f_{\mathrm{dist}}(x) \in [d_{\min}, d_{\max}].$$

En pratique, cette contrainte est résolue à l'aide d'un contracteur inverse, noté $\mathrm{CtcInverse}(f_{\mathrm{dist}}, [d_{\min}, d_{\max}])$, qui réduit le domaine de $x$ en ne conservant que les positions compatibles avec la mesure et la boîte du voisin.

\paragraph{Fusion des mesures}
Dans le cas où le bateau $S_1$ dispose de mesures vers deux voisins (par exemple $d_{01}$ et $d_{12}$), nous construisons un contracteur pour chaque contrainte, notés respectivement $C_{d_{01}}$ et $C_{d_{12}}$. La correction globale s'obtient par l'intersection de ces contraintes avec l'ensemble des positions courantes $C_{S1}(t)$ :

$$C_{S1}(t) \leftarrow C_{S1}(t) \cap \left( C_{d_{01}} \cap C_{d_{12}} \right).$$

\begin{figure}[H]
\centering
\scalebox{0.70}{\SchemaIntersection}
\caption{Exemple de contraction par intersection : $C_{S1}(t) \cap C_{d_{01}} \cap C_{d_{12}}$.}
\label{fig:schema_intersection}
\end{figure}

Cette opération réduit l'ensemble des possibles en ne gardant que l'intersection entre l'estimation courante et les anneaux de distances définis par les voisins, comme illustré par la Figure~\ref{fig:schema_intersection}.

\newpage

\section*{Implémentation de l'algorithme de localisation}

Cette section décrit, en pseudocode et en langage accessible, le déroulé de l'algorithme de prédiction/correction utilisé dans \texttt{fleet\_prediction.py}. Nous utilisons les noms introduits précédemment : le bateau mère \texttt{MS0} et les éclaireurs \texttt{S1}, \texttt{S2}. Le but est d'indiquer à quel moment se produisent les opérations principales : prédiction (dead‑reckoning), construction des contracteurs de distance, intersection des contracteurs et émission des boîtes voisins.

Remarque : les opérations sur contracteurs sont indiquées de façon informelle, l'objectif est la clarté du flux plutôt que la précision. La version de l'algorithme sera légèrement différente car on écrira l'algorithme du point de vue d'un bateau donné pour montrer qu'il marche avec une quantité d'information limitée.

\subsection*{Vue d'ensemble pour S1}

À chaque cycle d'échange (instant acoustique) :
- récupérer les mesures locales (dead‑reckoning : cap, vitesse)
- prédire l'ensemble compatible au nouvel instant (translation/inflation) ;
- collecter les mesures acoustiques disponibles ($d_{01},d_{12}, bb_{MS0}, bb_{S2}$) et la boîte GPS si fournie ;
- construire les contracteurs de distance pour chaque mesure et les combiner par intersection ;
- corriger chaque contracteur équivalent local en l'intersectant avec le contracteur de distances correspondant ;

\subsection*{Pseudocode — version récursive}
\begin{algo-box}[label=alg:recursive]{BoatPredictionRecursive (Vue locale S1)}
\begin{algorithmic}[1]
    \State \textbf{Initialisation:} $C_{S1} \gets \mathrm{CtcWrapper}(\text{initial box})$
    \Statex % Saut de ligne pour aérer
    \For{chaque pas acoustique $t$}
        \LComment{1. Phase de Prédiction (Dead-Reckoning)}
        \State $d_{S1} \gets \Call{IntegrateAndFilter}{cap, speed, S1}$ 
        \State Définir $f_{\mathrm{back},S1}(x) \gets x - d_{S1}$
        \State $C_{S1} \gets \mathrm{CtcInverse}(f_{\mathrm{back},S1}, C_{S1})$ 
        \Statex
        \LComment{2. Phase de Communication}
        \State \textbf{Envoyer} $bb_{S1}$ (IntervalVector) aux voisins
        \State \textbf{Recevoir} $bb_{MS0}$, $bb_{S2}$
        \State \textbf{Lire} les distances acoustiques $d_{01}, d_{12}$
        \Statex
        \LComment{3. Phase de Correction (Contraction)}
        \State \textcolor{gray}{\itshape \% Construction des contracteurs de distance}
        \State $C_{d01} \gets \mathrm{CtcInverse}\bigl(f_{\mathrm{dist}}(\cdot,MS0),\;d_{01}\bigr)$ 
        \State $C_{d12} \gets \mathrm{CtcInverse}\bigl(f_{\mathrm{dist}}(\cdot,S2),\;d_{12}\bigr)$
        \Statex
        \State \textcolor{gray}{\itshape \% Intersection et mise à jour}
        \State $C_{\mathrm{dist},S1} \gets C_{d01} \cap C_{d12}$
        \State $C_{S1} \gets C_{S1} \cap C_{\mathrm{dist},S1}$
        \Statex
        \If{gps box disponible}
            \State $C_{S1} \gets C_{S1} \cap \mathrm{CtcWrapper}(gps\_box)$
        \EndIf
    \EndFor
\end{algorithmic}
\end{algo-box}

\subsection*{Pseudocode — version non‑récursive (pavage)}
\begin{algo-box}[label=alg:non_recursive]{BoatPredictionNonRecursive (Pavage)}
\begin{algorithmic}[1]
    \State \textbf{Initialisation:} $C_{S1} \gets \mathrm{CtcWrapper}(\text{initial box})$
    \State \colorbox{yellow!20}{$pavage\_S1 \gets \mathrm{SIVIA}(C_{S1})$} \Comment{Pavage initial}
    \Statex
    \For{chaque pas acoustique $t$}
        \LComment{1. Prédiction via Pavage}
        \State $d_{S1} \gets \Call{IntegrateAndFilter}{S1}$
        \State Définir $f_{\mathrm{back},S1}(x) \gets x - d_{S1}$
        \State \colorbox{yellow!20}{$C_{S1} \gets \mathrm{CtcInverse}(f_{\mathrm{back},S1},\;\mathrm{CtcWrapper}(pavage\_S1))$}
        \Statex
        \LComment{2. Communication \& Lecture}
        \State \textbf{Envoyer} $bb_{S1}$; \textbf{Recevoir} $bb_{MS0}, bb_{S2}$; \textbf{Lire} $d_{01}, d_{12}$
        \Statex
        \LComment{3. Correction}
        \State $C_{d01} \gets \mathrm{CtcInverse}\bigl(f_{\mathrm{dist}}(\cdot,MS0),\;d_{01}\bigr)$
        \State $C_{d12} \gets \mathrm{CtcInverse}\bigl(f_{\mathrm{dist}}(\cdot,S2),\;d_{12}\bigr)$
        \Statex
        \State $C_{\mathrm{dist},S1} \gets C_{d01} \cap C_{d12}$
        \State $C_{S1} \gets C_{S1} \cap C_{\mathrm{dist},S1}$
        \If{gps box disponible}
            \State $C_{S1} \gets C_{S1} \cap \mathrm{CtcWrapper}(gps\_box)$
        \EndIf
        \Statex
        \LComment{4. Re-Pavage (Spécifique non-récursif)}
        \State \colorbox{yellow!20}{$pavage\_S1 \gets \mathrm{SIVIA}(C_{S1})$} \Comment{Mise à jour fine de la forme}
    \EndFor
\end{algorithmic}
\end{algo-box}


\end{document}

